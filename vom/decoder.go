// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package vom

import (
	"errors"
	"fmt"
	"io"
	"reflect"

	"v.io/v23/vdl"
)

var (
	errDecodeNil           = errors.New("vom: invalid decode into nil interface{}")
	errDecodeNilRawValue   = errors.New("vom: invalid decode into nil *RawValue")
	errDecodeInvalidTypeID = errors.New("vom: invalid type id")
	errDecodeZeroTypeID    = errors.New("vom: zero type id")
	errIndexOutOfRange     = errors.New("vom: index out of range")
)

// Decoder manages the receipt and unmarshalling of typed values from the other
// side of a connection.
type Decoder struct {
	buf     *decbuf
	typeDec *TypeDecoder
}

// NewDecoder returns a new Decoder that reads from the given reader. The
// Decoder understands all formats generated by the Encoder.
func NewDecoder(r io.Reader) (*Decoder, error) {
	buf := newDecbuf(r)
	if err := readMagicByte(buf); err != nil {
		return nil, err
	}
	return newDecoder(buf, newTypeDecoder(buf)), nil
}

// NewDecoderWithTypeDecoder returns a new Decoder that reads from the given
// reader. Types will be decoded separately through the given typeDec.
func NewDecoderWithTypeDecoder(r io.Reader, typeDec *TypeDecoder) (*Decoder, error) {
	buf := newDecbuf(r)
	if err := readMagicByte(buf); err != nil {
		return nil, err
	}
	return newDecoder(buf, typeDec), nil
}

func newDecoder(buf *decbuf, typeDec *TypeDecoder) *Decoder {
	return &Decoder{buf, typeDec}
}

// Decode reads the next value from the reader(s) and stores it in value v.
// The type of v need not exactly match the type of the originally encoded
// value; decoding succeeds as long as the values are compatible.
//
//   Types that are special-cased, only for v:
//     *RawValue  - Store raw (uninterpreted) bytes in v.
//
//   Types that are special-cased, recursively throughout v:
//     *vdl.Value    - Decode into v.
//     reflect.Value - Decode into v, which must be settable.
//
// Decoding into a RawValue captures the value in a raw form, which may be
// subsequently passed to an Encoder for transcoding.
//
// Decode(nil) always returns an error.  Use Ignore() to ignore the next value.
func (d *Decoder) Decode(v interface{}) error {
	switch tv := v.(type) {
	case nil:
		return errDecodeNil
	case *RawValue:
		if tv == nil {
			return errDecodeNilRawValue
		}
		return d.decodeRaw(tv)
	}
	valType, err := d.decodeValueType()
	if err != nil {
		return err
	}
	return d.decodeValueMsg(valType, v)
}

// Ignore ignores the next value from the reader.
func (d *Decoder) Ignore() error {
	valType, err := d.decodeValueType()
	if err != nil {
		return err
	}
	valLen, err := d.decodeValueByteLen(valType)
	if err != nil {
		return err
	}
	return d.buf.Skip(valLen)
}

func (d *Decoder) decodeRaw(raw *RawValue) error {
	valType, err := d.decodeValueType()
	if err != nil {
		return err
	}
	valLen, err := d.decodeValueByteLen(valType)
	if err != nil {
		return err
	}
	raw.typeDec = d.typeDec
	raw.valType = valType
	if cap(raw.data) >= valLen {
		raw.data = raw.data[:valLen]
	} else {
		raw.data = make([]byte, valLen)
	}
	return d.buf.ReadFull(raw.data)
}

// decodeWireType decodes the next type definition message and returns its
// type id.
func (d *Decoder) decodeWireType(wt *wireType) (typeId, error) {
	id, err := binaryDecodeInt(d.buf)
	if err != nil {
		return 0, err
	}
	switch {
	case id == 0:
		return 0, errDecodeZeroTypeID
	case id > 0:
		return 0, errDecodeInvalidTypeID
	}
	// This is a type message, the typeId is -id.
	tid := typeId(-id)
	// Decode the wire type like a regular value.
	if err := d.decodeValueMsg(wireTypeType, wt); err != nil {
		return 0, err
	}
	return tid, nil
}

// decodeValueType returns the type of the next value message. Any type
// definition messages it encounters along the way are decoded and sent
// to the type decoder.
func (d *Decoder) decodeValueType() (*vdl.Type, error) {
	for {
		id, err := binaryDecodeInt(d.buf)
		if err != nil {
			return nil, err
		}
		switch {
		case id > 0:
			// This is a value message, the typeId is +id.
			tid := typeId(+id)
			tt, err := d.typeDec.lookupType(tid)
			if err != nil {
				return nil, err
			}
			return tt, nil
		case id < 0:
			// This is a type message, the typeId is -id.
			tid := typeId(-id)
			// Decode the wireType like a regular value, and pass it to type decoder.
			var wt wireType
			if err := d.decodeValueMsg(wireTypeType, &wt); err != nil {
				return nil, err
			}
			if err := d.typeDec.addWireType(tid, wt); err != nil {
				return nil, err
			}
		case id == 0:
			return nil, errDecodeZeroTypeID
		}
	}
}

// decodeValueByteLen returns the byte length of the next value.
func (d *Decoder) decodeValueByteLen(tt *vdl.Type) (int, error) {
	if hasBinaryMsgLen(tt) {
		// Use the explicit message length.
		msgLen, err := binaryDecodeLen(d.buf)
		if err != nil {
			return 0, err
		}
		return msgLen, nil
	}
	// No explicit message length, but the length can be computed.
	switch {
	case tt.Kind() == vdl.Byte:
		// Single byte is always encoded as 1 byte.
		return 1, nil
	case tt.Kind() == vdl.Array && tt.IsBytes():
		// Byte arrays are exactly their length and encoded with 1-byte header.
		return tt.Len() + 1, nil
	case tt.Kind() == vdl.String || tt.IsBytes():
		// Strings and byte lists are encoded with a length header.
		strlen, bytelen, err := binaryPeekUint(d.buf)
		switch {
		case err != nil:
			return 0, err
		case strlen > maxBinaryMsgLen:
			return 0, errMsgLen
		}
		return int(strlen) + bytelen, nil
	default:
		// Must be a primitive, which is encoded as an underlying uint.
		return binaryPeekUintByteLen(d.buf)
	}
}

// decodeValueMsg decodes the rest of the message assuming type tt, handling
// the optional message length.
func (d *Decoder) decodeValueMsg(tt *vdl.Type, v interface{}) error {
	target, err := vdl.ReflectTarget(reflect.ValueOf(v))
	if err != nil {
		return err
	}
	if hasBinaryMsgLen(tt) {
		msgLen, err := binaryDecodeLen(d.buf)
		if err != nil {
			return err
		}
		d.buf.SetLimit(msgLen)
	}
	err = d.decodeValue(tt, target)
	if err != nil {
		return err
	}
	leftover := d.buf.RemoveLimit()
	if leftover > 0 {
		return fmt.Errorf("vom: %d leftover bytes", leftover)
	}
	return nil
}

// decodeValue decodes the rest of the message assuming type tt.
func (d *Decoder) decodeValue(tt *vdl.Type, target vdl.Target) error {
	ttFrom := tt
	if tt.Kind() == vdl.Optional {
		// If the type is optional, we expect to see either WireCtrlNil or the actual
		// value, but not both.  And thus, we can just peek for the WireCtrlNil here.
		switch ctrl, err := binaryPeekControl(d.buf); {
		case err != nil:
			return err
		case ctrl == WireCtrlNil:
			d.buf.Skip(1)
			return target.FromNil(ttFrom)
		}
		tt = tt.Elem()
	}
	if tt.IsBytes() {
		len, err := binaryDecodeLenOrArrayLen(d.buf, tt)
		if err != nil {
			return err
		}
		bytes, err := d.buf.ReadBuf(len)
		if err != nil {
			return err
		}
		return target.FromBytes(bytes, ttFrom)
	}
	switch kind := tt.Kind(); kind {
	case vdl.Bool:
		v, err := binaryDecodeBool(d.buf)
		if err != nil {
			return err
		}
		return target.FromBool(v, ttFrom)
	case vdl.Byte:
		v, err := d.buf.ReadByte()
		if err != nil {
			return err
		}
		return target.FromUint(uint64(v), ttFrom)
	case vdl.Uint16, vdl.Uint32, vdl.Uint64:
		v, err := binaryDecodeUint(d.buf)
		if err != nil {
			return err
		}
		return target.FromUint(v, ttFrom)
	case vdl.Int16, vdl.Int32, vdl.Int64:
		v, err := binaryDecodeInt(d.buf)
		if err != nil {
			return err
		}
		return target.FromInt(v, ttFrom)
	case vdl.Float32, vdl.Float64:
		v, err := binaryDecodeFloat(d.buf)
		if err != nil {
			return err
		}
		return target.FromFloat(v, ttFrom)
	case vdl.Complex64, vdl.Complex128:
		re, err := binaryDecodeFloat(d.buf)
		if err != nil {
			return err
		}
		im, err := binaryDecodeFloat(d.buf)
		if err != nil {
			return err
		}
		return target.FromComplex(complex(re, im), ttFrom)
	case vdl.String:
		v, err := binaryDecodeString(d.buf)
		if err != nil {
			return err
		}
		return target.FromString(v, ttFrom)
	case vdl.Enum:
		index, err := binaryDecodeUint(d.buf)
		switch {
		case err != nil:
			return err
		case index >= uint64(tt.NumEnumLabel()):
			return errIndexOutOfRange
		}
		return target.FromEnumLabel(tt.EnumLabel(int(index)), ttFrom)
	case vdl.TypeObject:
		id, err := binaryDecodeUint(d.buf)
		if err != nil {
			return err
		}
		typeobj, err := d.typeDec.lookupType(typeId(id))
		if err != nil {
			return err
		}
		return target.FromTypeObject(typeobj)
	case vdl.Array, vdl.List:
		len, err := binaryDecodeLenOrArrayLen(d.buf, tt)
		if err != nil {
			return err
		}
		listTarget, err := target.StartList(ttFrom, len)
		if err != nil {
			return err
		}
		for ix := 0; ix < len; ix++ {
			elem, err := listTarget.StartElem(ix)
			if err != nil {
				return err
			}
			if err := d.decodeValue(tt.Elem(), elem); err != nil {
				return err
			}
			if err := listTarget.FinishElem(elem); err != nil {
				return err
			}
		}
		return target.FinishList(listTarget)
	case vdl.Set:
		len, err := binaryDecodeLen(d.buf)
		if err != nil {
			return err
		}
		setTarget, err := target.StartSet(ttFrom, len)
		if err != nil {
			return err
		}
		for ix := 0; ix < len; ix++ {
			key, err := setTarget.StartKey()
			if err != nil {
				return err
			}
			if err := d.decodeValue(tt.Key(), key); err != nil {
				return err
			}
			switch err := setTarget.FinishKey(key); {
			case err == vdl.ErrFieldNoExist:
				continue
			case err != nil:
				return err
			}
		}
		return target.FinishSet(setTarget)
	case vdl.Map:
		len, err := binaryDecodeLen(d.buf)
		if err != nil {
			return err
		}
		mapTarget, err := target.StartMap(ttFrom, len)
		if err != nil {
			return err
		}
		for ix := 0; ix < len; ix++ {
			key, err := mapTarget.StartKey()
			if err != nil {
				return err
			}
			if err := d.decodeValue(tt.Key(), key); err != nil {
				return err
			}
			switch field, err := mapTarget.FinishKeyStartField(key); {
			case err == vdl.ErrFieldNoExist:
				if err := d.ignoreValue(tt.Elem()); err != nil {
					return err
				}
			case err != nil:
				return err
			default:
				if err := d.decodeValue(tt.Elem(), field); err != nil {
					return err
				}
				if err := mapTarget.FinishField(key, field); err != nil {
					return err
				}
			}
		}
		return target.FinishMap(mapTarget)
	case vdl.Struct:
		fieldsTarget, err := target.StartFields(ttFrom)
		if err != nil {
			return err
		}
		// Loop through decoding the 0-based field index and corresponding field.
		decodedFields := make([]bool, tt.NumField())
		for {
			index, ctrl, err := binaryDecodeUintWithControl(d.buf)
			switch {
			case err != nil:
				return err
			case ctrl == WireCtrlEnd:
				// Fill not-yet-decoded fields with their zero values.
				for index, decoded := range decodedFields {
					if decoded {
						continue
					}
					ttfield := tt.Field(index)
					switch key, field, err := fieldsTarget.StartField(ttfield.Name); {
					case err == vdl.ErrFieldNoExist:
						// Ignore it.
					case err != nil:
						return err
					default:
						if err := vdl.FromValue(field, vdl.ZeroValue(ttfield.Type)); err != nil {
							return err
						}
						if err := fieldsTarget.FinishField(key, field); err != nil {
							return err
						}
					}
				}
				return target.FinishFields(fieldsTarget)
			case ctrl != 0:
				return fmt.Errorf("vom: unexpected control byte 0x%x", ctrl)
			case index >= uint64(tt.NumField()):
				return errIndexOutOfRange
			}
			ttfield := tt.Field(int(index))
			switch key, field, err := fieldsTarget.StartField(ttfield.Name); {
			case err == vdl.ErrFieldNoExist:
				if err := d.ignoreValue(ttfield.Type); err != nil {
					return err
				}
			case err != nil:
				return err
			default:
				if err := d.decodeValue(ttfield.Type, field); err != nil {
					return err
				}
				if err := fieldsTarget.FinishField(key, field); err != nil {
					return err
				}
			}
			decodedFields[index] = true
		}
	case vdl.Union:
		fieldsTarget, err := target.StartFields(ttFrom)
		if err != nil {
			return err
		}
		index, err := binaryDecodeUint(d.buf)
		switch {
		case err != nil:
			return err
		case index >= uint64(tt.NumField()):
			return errIndexOutOfRange
		}
		ttfield := tt.Field(int(index))
		key, field, err := fieldsTarget.StartField(ttfield.Name)
		if err != nil {
			return err
		}
		if err := d.decodeValue(ttfield.Type, field); err != nil {
			return err
		}
		if err := fieldsTarget.FinishField(key, field); err != nil {
			return err
		}
		return target.FinishFields(fieldsTarget)
	case vdl.Any:
		switch id, ctrl, err := binaryDecodeUintWithControl(d.buf); {
		case err != nil:
			return err
		case ctrl == WireCtrlNil:
			return target.FromNil(vdl.AnyType)
		case ctrl != 0:
			return fmt.Errorf("vom: unexpected control byte 0x%x", ctrl)
		default:
			elemType, err := d.typeDec.lookupType(typeId(id))
			if err != nil {
				return err
			}
			return d.decodeValue(elemType, target)
		}
	default:
		panic(fmt.Errorf("vom: decodeValue unhandled type %v", tt))
	}
}

// ignoreValue ignores the rest of the value of type t. This is used to ignore
// unknown struct fields.
func (d *Decoder) ignoreValue(tt *vdl.Type) error {
	if tt.IsBytes() {
		len, err := binaryDecodeLenOrArrayLen(d.buf, tt)
		if err != nil {
			return err
		}
		return d.buf.Skip(len)
	}
	switch kind := tt.Kind(); kind {
	case vdl.Bool, vdl.Byte:
		return d.buf.Skip(1)
	case vdl.Uint16, vdl.Uint32, vdl.Uint64, vdl.Int16, vdl.Int32, vdl.Int64, vdl.Float32, vdl.Float64, vdl.Enum, vdl.TypeObject:
		// The underlying encoding of all these types is based on uint.
		return binaryIgnoreUint(d.buf)
	case vdl.Complex64, vdl.Complex128:
		// Complex is encoded as two floats, so we can simply ignore two uints.
		if err := binaryIgnoreUint(d.buf); err != nil {
			return err
		}
		return binaryIgnoreUint(d.buf)
	case vdl.String:
		return binaryIgnoreString(d.buf)
	case vdl.Array, vdl.List, vdl.Set, vdl.Map:
		len, err := binaryDecodeLenOrArrayLen(d.buf, tt)
		if err != nil {
			return err
		}
		for ix := 0; ix < len; ix++ {
			if kind == vdl.Set || kind == vdl.Map {
				if err := d.ignoreValue(tt.Key()); err != nil {
					return err
				}
			}
			if kind == vdl.Array || kind == vdl.List || kind == vdl.Map {
				if err := d.ignoreValue(tt.Elem()); err != nil {
					return err
				}
			}
		}
		return nil
	case vdl.Struct:
		// Loop through decoding the 0-based field index and corresponding field.
		for {
			switch index, ctrl, err := binaryDecodeUintWithControl(d.buf); {
			case err != nil:
				return err
			case ctrl == WireCtrlEnd:
				return nil
			case ctrl != 0:
				return fmt.Errorf("vom: unexpected control byte 0x%x", ctrl)
			case index >= uint64(tt.NumField()):
				return errIndexOutOfRange
			default:
				ttfield := tt.Field(int(index))
				if err := d.ignoreValue(ttfield.Type); err != nil {
					return err
				}
			}
		}
	case vdl.Union:
		switch index, err := binaryDecodeUint(d.buf); {
		case err != nil:
			return err
		case index >= uint64(tt.NumField()):
			return errIndexOutOfRange
		default:
			ttfield := tt.Field(int(index))
			return d.ignoreValue(ttfield.Type)
		}
	case vdl.Any:
		switch id, ctrl, err := binaryDecodeUintWithControl(d.buf); {
		case err != nil:
			return err
		case ctrl == WireCtrlNil:
			return nil
		case ctrl != 0:
			return fmt.Errorf("vom: unexpected control byte 0x%x", ctrl)
		default:
			elemType, err := d.typeDec.lookupType(typeId(id))
			if err != nil {
				return err
			}
			return d.ignoreValue(elemType)
		}
	default:
		panic(fmt.Errorf("vom: ignoreValue unhandled type %v", tt))
	}
}

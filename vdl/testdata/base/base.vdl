// Package base is a simple single-file test of vdl functionality.
package base

type (
	NamedBool       bool
	NamedByte       byte
	NamedUint16     uint16
	NamedUint32     uint32
	NamedUint64     uint64
	NamedInt16      int16
	NamedInt32      int32
	NamedInt64      int64
	NamedFloat32    float32
	NamedFloat64    float64
	NamedComplex64  complex64
	NamedComplex128 complex128
	NamedString     string
	NamedEnum       enum{A;B;C}
	NamedArray      [2]bool
	NamedList       []uint32
	NamedSet        set[string]
	NamedMap        map[string]float32
	NamedStruct     struct{A bool;B string;C int32}
	NamedUnion      union{A bool;B string;C int32}
)

type Scalars struct {
	A0  bool
	A1  byte
	A2  uint16
	A3  uint32
	A4  uint64
	A5  int16
	A6  int32
	A7  int64
	A8  float32
	A9  float64
	A10 complex64
	A11 complex128
	A12 string
	A13 error
	A14 any
	A15 typeobject

	B0  NamedBool
	B1  NamedByte
	B2  NamedUint16
	B3  NamedUint32
	B4  NamedUint64
	B5  NamedInt16
	B6  NamedInt32
	B7  NamedInt64
	B8  NamedFloat32
	B9  NamedFloat64
	B10 NamedComplex64
	B11 NamedComplex128
	B12 NamedString
	B13 NamedEnum
	B14 NamedUnion
}

// These are all scalars that may be used as map or set keys.
type KeyScalars struct {
	A0  bool
	A1  byte
	A2  uint16
	A3  uint32
	A4  uint64
	A5  int16
	A6  int32
	A7  int64
	A8  float32
	A9  float64
	A10 complex64
	A11 complex128
	A12 string

	B0  NamedBool
	B1  NamedByte
	B2  NamedUint16
	B3  NamedUint32
	B4  NamedUint64
	B5  NamedInt16
	B6  NamedInt32
	B7  NamedInt64
	B8  NamedFloat32
	B9  NamedFloat64
	B10 NamedComplex64
	B11 NamedComplex128
	B12 NamedString
}

type ScalarsArray [2]Scalars

type Composites struct {
	A0 Scalars
	A1 ScalarsArray
	A2 []Scalars
	A3 set[KeyScalars]
	A4 map[string]Scalars
	A5 map[KeyScalars][]map[string]complex128
}

type CompositesArray [2]Composites

type CompComp struct {
	A0 Composites
	A1 CompositesArray
	A2 []Composites
	A3 map[string]Composites
	A4 map[KeyScalars][]map[string]Composites
}

// NestedArgs is defined before Args; that's allowed in regular Go, and also
// allowed in our vdl files.  The compiler will re-order dependent types to ease
// code generation in other languages.
type NestedArgs struct {
	Args Args
}

// Args will be reordered to show up before NestedArgs in the generated output.
type Args struct {
	A int32
	B int32
}

const (
	Cbool = true
	Cbyte = byte(1)
	Cint32 = int32(2)
	Cint64 = int64(3)
	Cuint32 = uint32(4)
	Cuint64 = uint64(5)
	Cfloat32 = float32(6)
	Cfloat64 = float64(7)
	CNamedBool = NamedBool(true)
	CNamedStruct = NamedStruct{A:true, B: "test",}
	Ccomplex64 = complex64(8+9i)
	Ccomplex128 = complex128(10+11i)
	Cstring = "foo"
	Cenum  = NamedEnum.A
	Cunion = NamedUnion{A: true}
	Carray = NamedArray{true, false}
	Clist  = []int32{1, 2, 3}
	// TODO(toddw): test multiple items after ordering is fixed.
	//Cset   = set[int32]{1, 2, 3}
	Cset   = set[int32]{1}
	// TODO(toddw): test multiple items after ordering is fixed.
	//cmap   = map[int32]string{1: "A", 2: "B", 3: "C"}
	Cmap   = map[int32]string{1: "A"}
	Cargs  = Args{1, 2}

	True = true
	Foo = "foo"
	Five = int32(5)
	SixSquared = Six*Six
	FiveSquared = Five*Five
	Six = uint64(6)

	CTObool       = typeobject(bool)
	CTOstring     = typeobject(string)
	CTObytes      = typeobject([]byte)
	CTObyte       = typeobject(byte)
	CTOuint16     = typeobject(uint16)
	CTOint16      = typeobject(int16)
	CTOfloat32    = typeobject(float32)
	CTOcomplex64  = typeobject(complex64)
	CTOenum       = typeobject(NamedEnum)
	CTOArray      = typeobject(NamedArray)
	CTOList       = typeobject([]string)
	CTOSet        = typeobject(set[string])
	CTOMap        = typeobject(map[string]int64)
	CTOStruct     = typeobject(Scalars)
	CTOUnion      = typeobject(NamedUnion)
	CTOTypeObject = typeobject(typeobject)
	CTOAny        = typeobject(any)
)

type ServiceA interface {
	MethodA1() error
	MethodA2(a int32, b string) (s string | error)
	MethodA3(a int32) stream<_, Scalars> (s string | error) {"tag", Six}
	MethodA4(a int32) stream<int32, string> error
}

type ServiceB interface {
	ServiceA
	MethodB1(a Scalars, b Composites) (c CompComp | error)
}

// Error definitions, which allow stable error-checking across different address
// spaces.
error (
	NoParams1() {"en":"en msg"}
	NoParams2() {RetryRefetch, "en":"en msg", "fr":"fr msg"}

	WithParams1(x string, y int32) {"en":"en x={x} y={y}"}
	WithParams2(x string, y int32) {
		RetryRefetch,
		"en":"en x={x} y={y}",
		"fr":"fr y={y} x={x}",
	}
)

// This is the input file for VOM test data, in the VDL config file format.  The
// purpose of this file is to make it easy to add VOM test cases for each
// generated language.
//
// In order to add new test cases, simply add new values to the list below.
// Test types are defined in the vomtype.vdl file in this directory; they can't
// appear in this file since they're not allowed in VDL config files.
//
// To re-generate the tests:
// 0) If your PATH does not include $VANADIUM_ROOT/veyron/go/bin, then prefix
//    commands 2 and 3 with PATH=$VANADIUM_ROOT/veyron/go/bin:$PATH
//    This way, the new binaries are run without overwriting existing dev tools.
// 1) veyron go install v.io/veyron/veyron2/vdl/vdl v.io/veyron/veyron2/vom2/vomtestgen
// 2) veyron run vomtestgen
// 3) veyron run vdl generate v.io/veyron/veyron2/vom2/...
//
// Running "vomtestgen" against this file produces the vomdata.vdl file, and
// running "vdl generate" against the resulting package produces the VOM test
// data in each generated language.
config = x

import (
	t "v.io/veyron/veyron2/vom2/testdata"
)

const x = []any{
	// Values of simple unnamed types.
	bool(true), bool(false),
	string(""), string("abc"),
	[]byte(""), []byte("def"),

	byte(0), byte(127), byte(255),

	uint16(0), uint16(1), uint16(2), uint16(63), uint16(64),
	uint16(127), uint16(128), uint16(255), uint16(256),
	uint16(0x7ffe), uint16(0x7fff), uint16(0xfffe), uint16(0xffff),

	uint32(0),
	uint32(0x7ffffe), uint32(0x7fffff),
	uint32(0xfffffe), uint32(0xffffff),
	uint32(0x7ffffffe), uint32(0x7fffffff),
	uint32(0xfffffffe), uint32(0xffffffff),

	uint64(0),
	uint64(0x7ffffffffe), uint64(0x7fffffffff),
	uint64(0xfffffffffe), uint64(0xffffffffff),
	uint64(0x7ffffffffffe), uint64(0x7fffffffffff),
	uint64(0xfffffffffffe), uint64(0xffffffffffff),
	uint64(0x7ffffffffffffe), uint64(0x7fffffffffffff),
	uint64(0xfffffffffffffe), uint64(0xffffffffffffff),
	uint64(0x7ffffffffffffffe), uint64(0x7fffffffffffffff),
	uint64(0xfffffffffffffffe), uint64(0xffffffffffffffff),

	int16(0), int16(1), int16(2), int16(63), int16(64),
	int16(127), int16(128), int16(255), int16(256),
	int16(0x7ffe), int16(0x7fff),

	int32(0),
	int32(0x7ffffe), int32(0x7fffff),
	int32(0xfffffe), int32(0xffffff),
	int32(0x7ffffffe), int32(0x7fffffff),

	int64(0),
	int64(1), int64(2),
	int64(0x7ffffffffe), int64(0x7fffffffff),
	int64(0xfffffffffe), int64(0xffffffffff),
	int64(0x7ffffffffffe), int64(0x7fffffffffff),
	int64(0xfffffffffffe), int64(0xffffffffffff),
	int64(0x7ffffffffffffe), int64(0x7fffffffffffff),
	int64(0xfffffffffffffe), int64(0xffffffffffffff),
	int64(0x7ffffffffffffffe), int64(0x7fffffffffffffff),

	int16(-1), int16(-2), int16(-64), int16(-65),
	int16(-128), int16(-129), int16(-256), int16(-257),
	int16(-0x7fff), int16(-0x8000),

	int32(-0x7fffff), int32(-0x800000),
	int32(-0xffffff), int32(-0x1000000),
	int32(-0x7fffffff), int32(-0x80000000),

	int64(-1), int64(-2),
	int64(-0x7fffffffff), int64(-0x8000000000),
	int64(-0xffffffffff), int64(-0x10000000000),
	int64(-0x7fffffffffff), int64(-0x800000000000),
	int64(-0xffffffffffff), int64(-0x1000000000000),
	int64(-0x7fffffffffffff), int64(-0x80000000000000),
	int64(-0xffffffffffffff), int64(-0x100000000000000),
	int64(-0x7fffffffffffffff), int64(-0x8000000000000000),

	float32(0), float32(32.5), float32(-32.5),
	float64(0), float64(64.5), float64(-64.5),
	complex64(0), complex64(64.5+64.5i), complex64(64.5-64.5i),
	complex128(0), complex128(128.5+128.5i), complex128(128.5-128.5i),

	// Values of simple named types.
	t.NBool(true), t.NBool(false),
	t.NString(""), t.NString("abc"),
	t.NByteSlice(""), t.NByteSlice("def"),
	t.NByte(0), t.NByte(127), t.NByte(255),
	t.NUint16(0), t.NUint16(0xffff),
	t.NUint32(0), t.NUint32(0xffffffff),
	t.NUint64(0), t.NUint64(0xffffffffffffffff),
	t.NInt16(0), t.NInt16(0x7fff), t.NInt16(-0x8000),
	t.NInt32(0), t.NInt32(0x7fffffff), t.NInt32(-0x80000000),
	t.NInt64(0), t.NInt64(0x7fffffffffffffff), t.NInt64(-0x8000000000000000),
	t.NFloat32(0), t.NFloat32(32.5), t.NFloat32(-32.5),
	t.NFloat64(0), t.NFloat64(64.5), t.NFloat64(-64.5),
	t.NComplex64(0), t.NComplex64(64.5+64.5i), t.NComplex64(64.5-64.5i),
	t.NComplex128(0), t.NComplex128(128.5+128.5i), t.NComplex128(128.5-128.5i),

	// Values of composite types.
	//
	// TODO(toddw): Add more than 1 entry to the set and map values, after
	// accounting for possible ordering differences.
	[2]uint64{1, 2}, t.NArray2Uint64{1, 2},
	[]uint64{1, 2}, t.NListUint64{1, 2},
	set[uint64]{1}, t.NSetUint64{1},
	map[uint64]string{1:"abc"}, t.NMapUint64String{1:"abc"},
	t.NStruct{A: true, B: "abc", C: 123 },
	?t.NStruct(nil), ?t.NStruct{}, ?t.NStruct{A: true, B: "abc", C: 123},

	// Values of special types.
	// TODO(toddw): Add tests for embedded Any, etc.
	t.NEnum.A, t.NEnum.B, t.NEnum.C,
	t.NUnion{A: true}, t.NUnion{A: false},
	t.NUnion{B: ""}, t.NUnion{B: "abc"},
	t.NUnion{C: 0}, t.NUnion{C: 123}, t.NUnion{C: -123},

	// Values of nested custom types.
	t.MBool(true), t.MBool(false),
	t.MStruct{A: true, B: t.NBool(true), C: t.MBool(true)},
	t.MStruct{D: nil}, t.MStruct{D: {}}, t.MStruct{D: {true, "abc", 123}},
	t.MStruct{F: "abc"}, t.MStruct{F: t.MBool(true)}, t.MStruct{F: ?t.NStruct{B: "abc"}},
	t.MList{t.NListUint64{4, 2}, t.NListUint64{}, t.NListUint64{99}},
	// TODO(bprosnitz) Add more than one entry to the map, after we have
	// support for testing reordered bytes.
	t.MMap{t.NFloat32(4.5): t.NListUint64{2,3}},

	// Values of typeobject types.
	typeobject(any),
	typeobject(bool),
	typeobject(uint16),typeobject(uint32),typeobject(uint64),
	typeobject(int16),typeobject(int32),typeobject(int64),
	typeobject(int16),typeobject(int32),typeobject(int64),
	typeobject(float32),typeobject(float64),
	typeobject(complex64),typeobject(complex128),
	typeobject(t.NBool),
	typeobject(t.NUint16),typeobject(t.NUint32),typeobject(t.NUint64),
	typeobject(t.NInt16),typeobject(t.NInt32),typeobject(t.NInt64),
	typeobject(t.NFloat32),typeobject(t.NFloat64),
	typeobject(t.NComplex64),typeobject(t.NComplex128),
	typeobject([2]uint64), typeobject(t.NArray2Uint64),
	typeobject([]uint64), typeobject(t.NListUint64),
	typeobject(set[uint64]), typeobject(t.NSetUint64),
	typeobject(map[uint64]string), typeobject(t.NMapUint64String),
	typeobject(t.NStruct),
	typeobject(t.NEnum), typeobject(t.NUnion),
}

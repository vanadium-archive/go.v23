// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: syncbase

package syncbase

import (
	"fmt"
	"reflect"
	"time"
	"v.io/v23/services/syncbase"
	"v.io/v23/vdl"
	vdltime "v.io/v23/vdlroot/time"
	"v.io/v23/vom"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

// Value contains a specific version of data for the row under conflict along
// with the write timestamp and hints associated with the version.
// State defines whether the value is empty or not. It can be empty for
// reasons like Deleted or Unknown.
// WriteTs is the write timestamp for this value.
type Value struct {
	State   syncbase.ValueState
	Val     *vom.RawBytes
	WriteTs time.Time
	// TODO(jlodhia): Since field Selection cannot be package private in VDL,
	// review the ConflictResolution API to see if we should keep this field
	// or not.
	Selection syncbase.ValueSelection
}

func (Value) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase.Value"`
}) {
}

func (m *Value) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.State == syncbase.ValueStateExists)
	if var4 {
		if err := fieldsTarget1.ZeroField("State"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("State")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.State.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := m.Val == nil || (m.Val.Type.Kind() == vdl.Any && m.Val.IsNil())
	if var7 {
		if err := fieldsTarget1.ZeroField("Val"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Val")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Val.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var wireValue8 vdltime.Time
	if err := vdltime.TimeFromNative(&wireValue8, m.WriteTs); err != nil {
		return err
	}

	var11 := (wireValue8 == vdltime.Time{})
	if var11 {
		if err := fieldsTarget1.ZeroField("WriteTs"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("WriteTs")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := wireValue8.FillVDLTarget(fieldTarget10, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
				return err
			}
		}
	}
	var14 := (m.Selection == syncbase.ValueSelectionLocal)
	if var14 {
		if err := fieldsTarget1.ZeroField("Selection"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget12, fieldTarget13, err := fieldsTarget1.StartField("Selection")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Selection.FillVDLTarget(fieldTarget13, tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget12, fieldTarget13); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Value) MakeVDLTarget() vdl.Target {
	return &ValueTarget{Value: m}
}

type ValueTarget struct {
	Value       *Value
	stateTarget syncbase.ValueStateTarget

	writeTsTarget   vdltime.TimeTarget
	selectionTarget syncbase.ValueSelectionTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ValueTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Value)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ValueTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "State":
		t.stateTarget.Value = &t.Value.State
		target, err := &t.stateTarget, error(nil)
		return nil, target, err
	case "Val":
		target, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.Val))
		return nil, target, err
	case "WriteTs":
		t.writeTsTarget.Value = &t.Value.WriteTs
		target, err := &t.writeTsTarget, error(nil)
		return nil, target, err
	case "Selection":
		t.selectionTarget.Value = &t.Value.Selection
		target, err := &t.selectionTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *ValueTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ValueTarget) ZeroField(name string) error {
	switch name {
	case "State":
		t.Value.State = syncbase.ValueStateExists
		return nil
	case "Val":
		t.Value.Val = vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType))
		return nil
	case "WriteTs":
		t.Value.WriteTs = time.Time{}
		return nil
	case "Selection":
		t.Value.Selection = syncbase.ValueSelectionLocal
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *ValueTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x Value) VDLIsZero() bool {
	if x.State != syncbase.ValueStateExists {
		return false
	}
	if x.Val != nil && !x.Val.VDLIsZero() {
		return false
	}
	if !x.WriteTs.IsZero() {
		return false
	}
	if x.Selection != syncbase.ValueSelectionLocal {
		return false
	}
	return true
}

func (x Value) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Value)(nil)).Elem()); err != nil {
		return err
	}
	if x.State != syncbase.ValueStateExists {
		if err := enc.NextField("State"); err != nil {
			return err
		}
		if err := x.State.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Val != nil && !x.Val.VDLIsZero() {
		if err := enc.NextField("Val"); err != nil {
			return err
		}
		if err := x.Val.VDLWrite(enc); err != nil {
			return err
		}
	}
	if !x.WriteTs.IsZero() {
		if err := enc.NextField("WriteTs"); err != nil {
			return err
		}
		var wire vdltime.Time
		if err := vdltime.TimeFromNative(&wire, x.WriteTs); err != nil {
			return err
		}
		if err := wire.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Selection != syncbase.ValueSelectionLocal {
		if err := enc.NextField("Selection"); err != nil {
			return err
		}
		if err := x.Selection.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Value) VDLRead(dec vdl.Decoder) error {
	*x = Value{
		Val: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "State":
			if err := x.State.VDLRead(dec); err != nil {
				return err
			}
		case "Val":
			if err := x.Val.VDLRead(dec); err != nil {
				return err
			}
		case "WriteTs":
			var wire vdltime.Time
			if err := wire.VDLRead(dec); err != nil {
				return err
			}
			if err := vdltime.TimeToNative(wire, &x.WriteTs); err != nil {
				return err
			}
		case "Selection":
			if err := x.Selection.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// ConflictRow represents a row under conflict.
// Key is the key for the row.
// LocalValue is the value present in the local db.
// RemoteValue is the value received via sync.
// AncestorValue is the value for the key which is the lowest common
// ancestor of the two values represented by LocalValue and RemoteValue.
// AncestorValue's state is NoExists if the ConflictRow is a part of the read set.
// BatchIds is a list of ids of all the batches that this row belongs to.
type ConflictRow struct {
	Key           string
	LocalValue    Value
	RemoteValue   Value
	AncestorValue Value
	BatchIds      []uint64
}

func (ConflictRow) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase.ConflictRow"`
}) {
}

func (m *ConflictRow) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Key == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Key"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Key")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Key), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.LocalValue == Value{
		Val: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
	})
	if var7 {
		if err := fieldsTarget1.ZeroField("LocalValue"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("LocalValue")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.LocalValue.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.RemoteValue == Value{
		Val: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
	})
	if var10 {
		if err := fieldsTarget1.ZeroField("RemoteValue"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("RemoteValue")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.RemoteValue.FillVDLTarget(fieldTarget9, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var13 := (m.AncestorValue == Value{
		Val: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
	})
	if var13 {
		if err := fieldsTarget1.ZeroField("AncestorValue"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("AncestorValue")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.AncestorValue.FillVDLTarget(fieldTarget12, tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	var var16 bool
	if len(m.BatchIds) == 0 {
		var16 = true
	}
	if var16 {
		if err := fieldsTarget1.ZeroField("BatchIds"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("BatchIds")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget17, err := fieldTarget15.StartList(tt.NonOptional().Field(4).Type, len(m.BatchIds))
			if err != nil {
				return err
			}
			for i, elem19 := range m.BatchIds {
				elemTarget18, err := listTarget17.StartElem(i)
				if err != nil {
					return err
				}
				if err := elemTarget18.FromUint(uint64(elem19), tt.NonOptional().Field(4).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget17.FinishElem(elemTarget18); err != nil {
					return err
				}
			}
			if err := fieldTarget15.FinishList(listTarget17); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ConflictRow) MakeVDLTarget() vdl.Target {
	return &ConflictRowTarget{Value: m}
}

type ConflictRowTarget struct {
	Value               *ConflictRow
	keyTarget           vdl.StringTarget
	localValueTarget    ValueTarget
	remoteValueTarget   ValueTarget
	ancestorValueTarget ValueTarget
	batchIdsTarget      __VDLTarget1_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ConflictRowTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ConflictRow)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ConflictRowTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Key":
		t.keyTarget.Value = &t.Value.Key
		target, err := &t.keyTarget, error(nil)
		return nil, target, err
	case "LocalValue":
		t.localValueTarget.Value = &t.Value.LocalValue
		target, err := &t.localValueTarget, error(nil)
		return nil, target, err
	case "RemoteValue":
		t.remoteValueTarget.Value = &t.Value.RemoteValue
		target, err := &t.remoteValueTarget, error(nil)
		return nil, target, err
	case "AncestorValue":
		t.ancestorValueTarget.Value = &t.Value.AncestorValue
		target, err := &t.ancestorValueTarget, error(nil)
		return nil, target, err
	case "BatchIds":
		t.batchIdsTarget.Value = &t.Value.BatchIds
		target, err := &t.batchIdsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *ConflictRowTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ConflictRowTarget) ZeroField(name string) error {
	switch name {
	case "Key":
		t.Value.Key = ""
		return nil
	case "LocalValue":
		t.Value.LocalValue = Value{
			Val: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
		}
		return nil
	case "RemoteValue":
		t.Value.RemoteValue = Value{
			Val: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
		}
		return nil
	case "AncestorValue":
		t.Value.AncestorValue = Value{
			Val: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
		}
		return nil
	case "BatchIds":
		t.Value.BatchIds = []uint64(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *ConflictRowTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []uint64
type __VDLTarget1_list struct {
	Value      *[]uint64
	elemTarget vdl.Uint64Target
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget1_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]uint64)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]uint64, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget1_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget1_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget1_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x ConflictRow) VDLIsZero() bool {
	if x.Key != "" {
		return false
	}
	if !x.LocalValue.VDLIsZero() {
		return false
	}
	if !x.RemoteValue.VDLIsZero() {
		return false
	}
	if !x.AncestorValue.VDLIsZero() {
		return false
	}
	if len(x.BatchIds) != 0 {
		return false
	}
	return true
}

func (x ConflictRow) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ConflictRow)(nil)).Elem()); err != nil {
		return err
	}
	if x.Key != "" {
		if err := enc.NextField("Key"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if !x.LocalValue.VDLIsZero() {
		if err := enc.NextField("LocalValue"); err != nil {
			return err
		}
		if err := x.LocalValue.VDLWrite(enc); err != nil {
			return err
		}
	}
	if !x.RemoteValue.VDLIsZero() {
		if err := enc.NextField("RemoteValue"); err != nil {
			return err
		}
		if err := x.RemoteValue.VDLWrite(enc); err != nil {
			return err
		}
	}
	if !x.AncestorValue.VDLIsZero() {
		if err := enc.NextField("AncestorValue"); err != nil {
			return err
		}
		if err := x.AncestorValue.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.BatchIds) != 0 {
		if err := enc.NextField("BatchIds"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_1(enc, x.BatchIds); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_1(enc vdl.Encoder, x []uint64) error {
	if err := enc.StartValue(vdl.TypeOf((*[]uint64)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(x[i]); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ConflictRow) VDLRead(dec vdl.Decoder) error {
	*x = ConflictRow{
		LocalValue: Value{
			Val: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
		},
		RemoteValue: Value{
			Val: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
		},
		AncestorValue: Value{
			Val: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
		},
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Key":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "LocalValue":
			if err := x.LocalValue.VDLRead(dec); err != nil {
				return err
			}
		case "RemoteValue":
			if err := x.RemoteValue.VDLRead(dec); err != nil {
				return err
			}
		case "AncestorValue":
			if err := x.AncestorValue.VDLRead(dec); err != nil {
				return err
			}
		case "BatchIds":
			if err := __VDLReadAnon_list_1(dec, &x.BatchIds); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_list_1(dec vdl.Decoder, x *[]uint64) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]uint64, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem uint64
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if elem, err = dec.DecodeUint(64); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

// ConflictRowSet contains a set of rows under conflict. It provides two different
// ways to access the same set.
// ByKey is a map of ConflictRows keyed by the row key.
// ByBatch is a map of []ConflictRows keyed by batch id. This map lets the client
// access all ConflictRows within this set that contain a given hint.
type ConflictRowSet struct {
	ByKey   map[string]ConflictRow
	ByBatch map[uint64][]ConflictRow
}

func (ConflictRowSet) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase.ConflictRowSet"`
}) {
}

func (m *ConflictRowSet) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var var4 bool
	if len(m.ByKey) == 0 {
		var4 = true
	}
	if var4 {
		if err := fieldsTarget1.ZeroField("ByKey"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ByKey")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget5, err := fieldTarget3.StartMap(tt.NonOptional().Field(0).Type, len(m.ByKey))
			if err != nil {
				return err
			}
			for key7, value9 := range m.ByKey {
				keyTarget6, err := mapTarget5.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget6.FromString(string(key7), tt.NonOptional().Field(0).Type.Key()); err != nil {
					return err
				}
				valueTarget8, err := mapTarget5.FinishKeyStartField(keyTarget6)
				if err != nil {
					return err
				}

				if err := value9.FillVDLTarget(valueTarget8, tt.NonOptional().Field(0).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget5.FinishField(keyTarget6, valueTarget8); err != nil {
					return err
				}
			}
			if err := fieldTarget3.FinishMap(mapTarget5); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var12 bool
	if len(m.ByBatch) == 0 {
		var12 = true
	}
	if var12 {
		if err := fieldsTarget1.ZeroField("ByBatch"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget10, fieldTarget11, err := fieldsTarget1.StartField("ByBatch")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget13, err := fieldTarget11.StartMap(tt.NonOptional().Field(1).Type, len(m.ByBatch))
			if err != nil {
				return err
			}
			for key15, value17 := range m.ByBatch {
				keyTarget14, err := mapTarget13.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget14.FromUint(uint64(key15), tt.NonOptional().Field(1).Type.Key()); err != nil {
					return err
				}
				valueTarget16, err := mapTarget13.FinishKeyStartField(keyTarget14)
				if err != nil {
					return err
				}

				listTarget18, err := valueTarget16.StartList(tt.NonOptional().Field(1).Type.Elem(), len(value17))
				if err != nil {
					return err
				}
				for i, elem20 := range value17 {
					elemTarget19, err := listTarget18.StartElem(i)
					if err != nil {
						return err
					}

					if err := elem20.FillVDLTarget(elemTarget19, tt.NonOptional().Field(1).Type.Elem().Elem()); err != nil {
						return err
					}
					if err := listTarget18.FinishElem(elemTarget19); err != nil {
						return err
					}
				}
				if err := valueTarget16.FinishList(listTarget18); err != nil {
					return err
				}
				if err := mapTarget13.FinishField(keyTarget14, valueTarget16); err != nil {
					return err
				}
			}
			if err := fieldTarget11.FinishMap(mapTarget13); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget10, fieldTarget11); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ConflictRowSet) MakeVDLTarget() vdl.Target {
	return &ConflictRowSetTarget{Value: m}
}

type ConflictRowSetTarget struct {
	Value         *ConflictRowSet
	byKeyTarget   __VDLTarget2_map
	byBatchTarget __VDLTarget3_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ConflictRowSetTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ConflictRowSet)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ConflictRowSetTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "ByKey":
		t.byKeyTarget.Value = &t.Value.ByKey
		target, err := &t.byKeyTarget, error(nil)
		return nil, target, err
	case "ByBatch":
		t.byBatchTarget.Value = &t.Value.ByBatch
		target, err := &t.byBatchTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *ConflictRowSetTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ConflictRowSetTarget) ZeroField(name string) error {
	switch name {
	case "ByKey":
		t.Value.ByKey = map[string]ConflictRow(nil)
		return nil
	case "ByBatch":
		t.Value.ByBatch = map[uint64][]ConflictRow(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *ConflictRowSetTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[string]ConflictRow
type __VDLTarget2_map struct {
	Value      *map[string]ConflictRow
	currKey    string
	currElem   ConflictRow
	keyTarget  vdl.StringTarget
	elemTarget ConflictRowTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget2_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]ConflictRow)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]ConflictRow)
	return t, nil
}
func (t *__VDLTarget2_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = reflect.Zero(reflect.TypeOf(t.currElem)).Interface().(ConflictRow)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget2_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[uint64][]ConflictRow
type __VDLTarget3_map struct {
	Value      *map[uint64][]ConflictRow
	currKey    uint64
	currElem   []ConflictRow
	keyTarget  vdl.Uint64Target
	elemTarget __VDLTarget4_list
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget3_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint64][]ConflictRow)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint64][]ConflictRow)
	return t, nil
}
func (t *__VDLTarget3_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget3_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = reflect.Zero(reflect.TypeOf(t.currElem)).Interface().([]ConflictRow)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget3_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget3_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// []ConflictRow
type __VDLTarget4_list struct {
	Value      *[]ConflictRow
	elemTarget ConflictRowTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget4_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]ConflictRow)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]ConflictRow, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget4_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget4_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget4_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x ConflictRowSet) VDLIsZero() bool {
	if len(x.ByKey) != 0 {
		return false
	}
	if len(x.ByBatch) != 0 {
		return false
	}
	return true
}

func (x ConflictRowSet) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ConflictRowSet)(nil)).Elem()); err != nil {
		return err
	}
	if len(x.ByKey) != 0 {
		if err := enc.NextField("ByKey"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_2(enc, x.ByKey); err != nil {
			return err
		}
	}
	if len(x.ByBatch) != 0 {
		if err := enc.NextField("ByBatch"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_3(enc, x.ByBatch); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_2(enc vdl.Encoder, x map[string]ConflictRow) error {
	if err := enc.StartValue(vdl.TypeOf((*map[string]ConflictRow)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_3(enc vdl.Encoder, x map[uint64][]ConflictRow) error {
	if err := enc.StartValue(vdl.TypeOf((*map[uint64][]ConflictRow)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_4(enc, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_4(enc vdl.Encoder, x []ConflictRow) error {
	if err := enc.StartValue(vdl.TypeOf((*[]ConflictRow)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ConflictRowSet) VDLRead(dec vdl.Decoder) error {
	*x = ConflictRowSet{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "ByKey":
			if err := __VDLReadAnon_map_2(dec, &x.ByKey); err != nil {
				return err
			}
		case "ByBatch":
			if err := __VDLReadAnon_map_3(dec, &x.ByBatch); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_map_2(dec vdl.Decoder, x *map[string]ConflictRow) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[string]ConflictRow
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]ConflictRow, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem ConflictRow
		{
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[string]ConflictRow)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_map_3(dec vdl.Decoder, x *map[uint64][]ConflictRow) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[uint64][]ConflictRow
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint64][]ConflictRow, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key uint64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem []ConflictRow
		{
			if err := __VDLReadAnon_list_4(dec, &elem); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[uint64][]ConflictRow)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_list_4(dec vdl.Decoder, x *[]ConflictRow) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]ConflictRow, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem ConflictRow
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

// ConflictScanSet contains a set of scans under conflict.
// ByBatch is a map of array of ScanOps keyed by batch id.
type ConflictScanSet struct {
	ByBatch map[uint64][]syncbase.ScanOp
}

func (ConflictScanSet) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase.ConflictScanSet"`
}) {
}

func (m *ConflictScanSet) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var var4 bool
	if len(m.ByBatch) == 0 {
		var4 = true
	}
	if var4 {
		if err := fieldsTarget1.ZeroField("ByBatch"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ByBatch")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget5, err := fieldTarget3.StartMap(tt.NonOptional().Field(0).Type, len(m.ByBatch))
			if err != nil {
				return err
			}
			for key7, value9 := range m.ByBatch {
				keyTarget6, err := mapTarget5.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget6.FromUint(uint64(key7), tt.NonOptional().Field(0).Type.Key()); err != nil {
					return err
				}
				valueTarget8, err := mapTarget5.FinishKeyStartField(keyTarget6)
				if err != nil {
					return err
				}

				listTarget10, err := valueTarget8.StartList(tt.NonOptional().Field(0).Type.Elem(), len(value9))
				if err != nil {
					return err
				}
				for i, elem12 := range value9 {
					elemTarget11, err := listTarget10.StartElem(i)
					if err != nil {
						return err
					}

					if err := elem12.FillVDLTarget(elemTarget11, tt.NonOptional().Field(0).Type.Elem().Elem()); err != nil {
						return err
					}
					if err := listTarget10.FinishElem(elemTarget11); err != nil {
						return err
					}
				}
				if err := valueTarget8.FinishList(listTarget10); err != nil {
					return err
				}
				if err := mapTarget5.FinishField(keyTarget6, valueTarget8); err != nil {
					return err
				}
			}
			if err := fieldTarget3.FinishMap(mapTarget5); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ConflictScanSet) MakeVDLTarget() vdl.Target {
	return &ConflictScanSetTarget{Value: m}
}

type ConflictScanSetTarget struct {
	Value         *ConflictScanSet
	byBatchTarget __VDLTarget5_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ConflictScanSetTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ConflictScanSet)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ConflictScanSetTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "ByBatch":
		t.byBatchTarget.Value = &t.Value.ByBatch
		target, err := &t.byBatchTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *ConflictScanSetTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ConflictScanSetTarget) ZeroField(name string) error {
	switch name {
	case "ByBatch":
		t.Value.ByBatch = map[uint64][]syncbase.ScanOp(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *ConflictScanSetTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[uint64][]syncbase.ScanOp
type __VDLTarget5_map struct {
	Value      *map[uint64][]syncbase.ScanOp
	currKey    uint64
	currElem   []syncbase.ScanOp
	keyTarget  vdl.Uint64Target
	elemTarget __VDLTarget6_list
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget5_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint64][]syncbase.ScanOp)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint64][]syncbase.ScanOp)
	return t, nil
}
func (t *__VDLTarget5_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget5_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = []syncbase.ScanOp(nil)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget5_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget5_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// []syncbase.ScanOp
type __VDLTarget6_list struct {
	Value      *[]syncbase.ScanOp
	elemTarget syncbase.ScanOpTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget6_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]syncbase.ScanOp)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]syncbase.ScanOp, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget6_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget6_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget6_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x ConflictScanSet) VDLIsZero() bool {
	if len(x.ByBatch) != 0 {
		return false
	}
	return true
}

func (x ConflictScanSet) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ConflictScanSet)(nil)).Elem()); err != nil {
		return err
	}
	if len(x.ByBatch) != 0 {
		if err := enc.NextField("ByBatch"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_5(enc, x.ByBatch); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_5(enc vdl.Encoder, x map[uint64][]syncbase.ScanOp) error {
	if err := enc.StartValue(vdl.TypeOf((*map[uint64][]syncbase.ScanOp)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_6(enc, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_6(enc vdl.Encoder, x []syncbase.ScanOp) error {
	if err := enc.StartValue(vdl.TypeOf((*[]syncbase.ScanOp)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ConflictScanSet) VDLRead(dec vdl.Decoder) error {
	*x = ConflictScanSet{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "ByBatch":
			if err := __VDLReadAnon_map_5(dec, &x.ByBatch); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_map_5(dec vdl.Decoder, x *map[uint64][]syncbase.ScanOp) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[uint64][]syncbase.ScanOp
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint64][]syncbase.ScanOp, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key uint64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem []syncbase.ScanOp
		{
			if err := __VDLReadAnon_list_6(dec, &elem); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[uint64][]syncbase.ScanOp)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_list_6(dec vdl.Decoder, x *[]syncbase.ScanOp) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]syncbase.ScanOp, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem syncbase.ScanOp
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

// Conflict contains information to fully specify a conflict. Since syncbase
// supports batches there can be one or more rows within the batch that has a
// conflict. Each of these rows will be sent together as part of a single
// conflict. Each row contains an Id of the batch to which it belongs,
// enabling the client to group together rows that are part of a batch. Note
// that a single row can be part of more than one batch.
//
// WriteSet contains rows that were written.
// ReadSet contains rows that were read within a batch corresponding to a row
// within the write set.
// ScanSet contains scans performed within a batch corresponding to a row
// within the write set.
// Batches is a map of unique ids to BatchInfo objects. The id is unique only in
// the context of a given conflict and is otherwise meaningless.
type Conflict struct {
	ReadSet  *ConflictRowSet
	WriteSet *ConflictRowSet
	ScanSet  *ConflictScanSet
	Batches  map[uint64]syncbase.BatchInfo
}

func (Conflict) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase.Conflict"`
}) {
}

func (m *Conflict) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.ReadSet == (*ConflictRowSet)(nil))
	if var4 {
		if err := fieldsTarget1.ZeroField("ReadSet"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ReadSet")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.ReadSet.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.WriteSet == (*ConflictRowSet)(nil))
	if var7 {
		if err := fieldsTarget1.ZeroField("WriteSet"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("WriteSet")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.WriteSet.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.ScanSet == (*ConflictScanSet)(nil))
	if var10 {
		if err := fieldsTarget1.ZeroField("ScanSet"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("ScanSet")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.ScanSet.FillVDLTarget(fieldTarget9, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var var13 bool
	if len(m.Batches) == 0 {
		var13 = true
	}
	if var13 {
		if err := fieldsTarget1.ZeroField("Batches"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Batches")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget14, err := fieldTarget12.StartMap(tt.NonOptional().Field(3).Type, len(m.Batches))
			if err != nil {
				return err
			}
			for key16, value18 := range m.Batches {
				keyTarget15, err := mapTarget14.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget15.FromUint(uint64(key16), tt.NonOptional().Field(3).Type.Key()); err != nil {
					return err
				}
				valueTarget17, err := mapTarget14.FinishKeyStartField(keyTarget15)
				if err != nil {
					return err
				}

				if err := value18.FillVDLTarget(valueTarget17, tt.NonOptional().Field(3).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget14.FinishField(keyTarget15, valueTarget17); err != nil {
					return err
				}
			}
			if err := fieldTarget12.FinishMap(mapTarget14); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Conflict) MakeVDLTarget() vdl.Target {
	return &ConflictTarget{Value: m}
}

type ConflictTarget struct {
	Value          *Conflict
	readSetTarget  __VDLTarget7_optional
	writeSetTarget __VDLTarget7_optional
	scanSetTarget  __VDLTarget8_optional
	batchesTarget  __VDLTarget9_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ConflictTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Conflict)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ConflictTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "ReadSet":
		t.readSetTarget.Value = &t.Value.ReadSet
		target, err := &t.readSetTarget, error(nil)
		return nil, target, err
	case "WriteSet":
		t.writeSetTarget.Value = &t.Value.WriteSet
		target, err := &t.writeSetTarget, error(nil)
		return nil, target, err
	case "ScanSet":
		t.scanSetTarget.Value = &t.Value.ScanSet
		target, err := &t.scanSetTarget, error(nil)
		return nil, target, err
	case "Batches":
		t.batchesTarget.Value = &t.Value.Batches
		target, err := &t.batchesTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *ConflictTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ConflictTarget) ZeroField(name string) error {
	switch name {
	case "ReadSet":
		t.Value.ReadSet = (*ConflictRowSet)(nil)
		return nil
	case "WriteSet":
		t.Value.WriteSet = (*ConflictRowSet)(nil)
		return nil
	case "ScanSet":
		t.Value.ScanSet = (*ConflictScanSet)(nil)
		return nil
	case "Batches":
		t.Value.Batches = map[uint64]syncbase.BatchInfo(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *ConflictTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// Optional ConflictRowSet
type __VDLTarget7_optional struct {
	Value      **ConflictRowSet
	elemTarget ConflictRowSetTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *__VDLTarget7_optional) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if *t.Value == nil {
		*t.Value = &ConflictRowSet{}
	}
	t.elemTarget.Value = *t.Value
	target, err := &t.elemTarget, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *__VDLTarget7_optional) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *__VDLTarget7_optional) FromNil(tt *vdl.Type) error {
	*t.Value = (*ConflictRowSet)(nil)
	return nil
}

// Optional ConflictScanSet
type __VDLTarget8_optional struct {
	Value      **ConflictScanSet
	elemTarget ConflictScanSetTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *__VDLTarget8_optional) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if *t.Value == nil {
		*t.Value = &ConflictScanSet{}
	}
	t.elemTarget.Value = *t.Value
	target, err := &t.elemTarget, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *__VDLTarget8_optional) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *__VDLTarget8_optional) FromNil(tt *vdl.Type) error {
	*t.Value = (*ConflictScanSet)(nil)
	return nil
}

// map[uint64]syncbase.BatchInfo
type __VDLTarget9_map struct {
	Value      *map[uint64]syncbase.BatchInfo
	currKey    uint64
	currElem   syncbase.BatchInfo
	keyTarget  vdl.Uint64Target
	elemTarget syncbase.BatchInfoTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget9_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint64]syncbase.BatchInfo)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint64]syncbase.BatchInfo)
	return t, nil
}
func (t *__VDLTarget9_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget9_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = syncbase.BatchInfo{}
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget9_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget9_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x Conflict) VDLIsZero() bool {
	if x.ReadSet != nil {
		return false
	}
	if x.WriteSet != nil {
		return false
	}
	if x.ScanSet != nil {
		return false
	}
	if len(x.Batches) != 0 {
		return false
	}
	return true
}

func (x Conflict) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Conflict)(nil)).Elem()); err != nil {
		return err
	}
	if x.ReadSet != nil {
		if err := enc.NextField("ReadSet"); err != nil {
			return err
		}
		enc.SetNextStartValueIsOptional()
		if err := enc.StartValue(vdl.TypeOf((*ConflictRowSet)(nil)).Elem()); err != nil {
			return err
		}
		if err := x.ReadSet.VDLWrite(enc); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.WriteSet != nil {
		if err := enc.NextField("WriteSet"); err != nil {
			return err
		}
		enc.SetNextStartValueIsOptional()
		if err := enc.StartValue(vdl.TypeOf((*ConflictRowSet)(nil)).Elem()); err != nil {
			return err
		}
		if err := x.WriteSet.VDLWrite(enc); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.ScanSet != nil {
		if err := enc.NextField("ScanSet"); err != nil {
			return err
		}
		enc.SetNextStartValueIsOptional()
		if err := enc.StartValue(vdl.TypeOf((*ConflictScanSet)(nil)).Elem()); err != nil {
			return err
		}
		if err := x.ScanSet.VDLWrite(enc); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if len(x.Batches) != 0 {
		if err := enc.NextField("Batches"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_7(enc, x.Batches); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_7(enc vdl.Encoder, x map[uint64]syncbase.BatchInfo) error {
	if err := enc.StartValue(vdl.TypeOf((*map[uint64]syncbase.BatchInfo)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Conflict) VDLRead(dec vdl.Decoder) error {
	*x = Conflict{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "ReadSet":
			if err := dec.StartValue(); err != nil {
				return err
			}
			if dec.IsNil() {
				if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x.ReadSet), dec.Type()) {
					return fmt.Errorf("incompatible optional %T, from %v", x.ReadSet, dec.Type())
				}
				x.ReadSet = nil
				if err := dec.FinishValue(); err != nil {
					return err
				}
			} else {
				x.ReadSet = new(ConflictRowSet)
				dec.IgnoreNextStartValue()
				if err := x.ReadSet.VDLRead(dec); err != nil {
					return err
				}
			}
		case "WriteSet":
			if err := dec.StartValue(); err != nil {
				return err
			}
			if dec.IsNil() {
				if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x.WriteSet), dec.Type()) {
					return fmt.Errorf("incompatible optional %T, from %v", x.WriteSet, dec.Type())
				}
				x.WriteSet = nil
				if err := dec.FinishValue(); err != nil {
					return err
				}
			} else {
				x.WriteSet = new(ConflictRowSet)
				dec.IgnoreNextStartValue()
				if err := x.WriteSet.VDLRead(dec); err != nil {
					return err
				}
			}
		case "ScanSet":
			if err := dec.StartValue(); err != nil {
				return err
			}
			if dec.IsNil() {
				if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x.ScanSet), dec.Type()) {
					return fmt.Errorf("incompatible optional %T, from %v", x.ScanSet, dec.Type())
				}
				x.ScanSet = nil
				if err := dec.FinishValue(); err != nil {
					return err
				}
			} else {
				x.ScanSet = new(ConflictScanSet)
				dec.IgnoreNextStartValue()
				if err := x.ScanSet.VDLRead(dec); err != nil {
					return err
				}
			}
		case "Batches":
			if err := __VDLReadAnon_map_7(dec, &x.Batches); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_map_7(dec vdl.Decoder, x *map[uint64]syncbase.BatchInfo) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[uint64]syncbase.BatchInfo
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint64]syncbase.BatchInfo, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key uint64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem syncbase.BatchInfo
		{
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[uint64]syncbase.BatchInfo)
		}
		tmpMap[key] = elem
	}
}

// ResolvedRow represents a result of resolution of a row under conflict.
// Key is the key for the row.
// Result is the result of the conflict resolution. Delete is represented
// by nil.
type ResolvedRow struct {
	Key    string
	Result *Value
}

func (ResolvedRow) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase.ResolvedRow"`
}) {
}

func (m *ResolvedRow) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Key == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Key"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Key")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Key), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Result == (*Value)(nil))
	if var7 {
		if err := fieldsTarget1.ZeroField("Result"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Result")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Result.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ResolvedRow) MakeVDLTarget() vdl.Target {
	return &ResolvedRowTarget{Value: m}
}

type ResolvedRowTarget struct {
	Value        *ResolvedRow
	keyTarget    vdl.StringTarget
	resultTarget __VDLTarget10_optional
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ResolvedRowTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ResolvedRow)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ResolvedRowTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Key":
		t.keyTarget.Value = &t.Value.Key
		target, err := &t.keyTarget, error(nil)
		return nil, target, err
	case "Result":
		t.resultTarget.Value = &t.Value.Result
		target, err := &t.resultTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *ResolvedRowTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ResolvedRowTarget) ZeroField(name string) error {
	switch name {
	case "Key":
		t.Value.Key = ""
		return nil
	case "Result":
		t.Value.Result = (*Value)(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *ResolvedRowTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// Optional Value
type __VDLTarget10_optional struct {
	Value      **Value
	elemTarget ValueTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *__VDLTarget10_optional) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if *t.Value == nil {
		*t.Value = &Value{
			Val: vom.RawBytesOf(vdl.ZeroValue(vdl.AnyType)),
		}
	}
	t.elemTarget.Value = *t.Value
	target, err := &t.elemTarget, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *__VDLTarget10_optional) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *__VDLTarget10_optional) FromNil(tt *vdl.Type) error {
	*t.Value = (*Value)(nil)
	return nil
}

func (x ResolvedRow) VDLIsZero() bool {
	return x == ResolvedRow{}
}

func (x ResolvedRow) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ResolvedRow)(nil)).Elem()); err != nil {
		return err
	}
	if x.Key != "" {
		if err := enc.NextField("Key"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Result != nil {
		if err := enc.NextField("Result"); err != nil {
			return err
		}
		enc.SetNextStartValueIsOptional()
		if err := enc.StartValue(vdl.TypeOf((*Value)(nil)).Elem()); err != nil {
			return err
		}
		if err := x.Result.VDLWrite(enc); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ResolvedRow) VDLRead(dec vdl.Decoder) error {
	*x = ResolvedRow{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Key":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Result":
			if err := dec.StartValue(); err != nil {
				return err
			}
			if dec.IsNil() {
				if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x.Result), dec.Type()) {
					return fmt.Errorf("incompatible optional %T, from %v", x.Result, dec.Type())
				}
				x.Result = nil
				if err := dec.FinishValue(); err != nil {
					return err
				}
			} else {
				x.Result = new(Value)
				dec.IgnoreNextStartValue()
				if err := x.Result.VDLRead(dec); err != nil {
					return err
				}
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// Resolution contains the applications reply to a conflict. It must contain a
// resolved value for each conflict row within the WriteSet of the given
// conflict.
// ResultSet is a map of row key to ResolvedRow.
type Resolution struct {
	ResultSet map[string]ResolvedRow
}

func (Resolution) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase.Resolution"`
}) {
}

func (m *Resolution) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var var4 bool
	if len(m.ResultSet) == 0 {
		var4 = true
	}
	if var4 {
		if err := fieldsTarget1.ZeroField("ResultSet"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ResultSet")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget5, err := fieldTarget3.StartMap(tt.NonOptional().Field(0).Type, len(m.ResultSet))
			if err != nil {
				return err
			}
			for key7, value9 := range m.ResultSet {
				keyTarget6, err := mapTarget5.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget6.FromString(string(key7), tt.NonOptional().Field(0).Type.Key()); err != nil {
					return err
				}
				valueTarget8, err := mapTarget5.FinishKeyStartField(keyTarget6)
				if err != nil {
					return err
				}

				if err := value9.FillVDLTarget(valueTarget8, tt.NonOptional().Field(0).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget5.FinishField(keyTarget6, valueTarget8); err != nil {
					return err
				}
			}
			if err := fieldTarget3.FinishMap(mapTarget5); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Resolution) MakeVDLTarget() vdl.Target {
	return &ResolutionTarget{Value: m}
}

type ResolutionTarget struct {
	Value           *Resolution
	resultSetTarget __VDLTarget11_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ResolutionTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Resolution)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ResolutionTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "ResultSet":
		t.resultSetTarget.Value = &t.Value.ResultSet
		target, err := &t.resultSetTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *ResolutionTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ResolutionTarget) ZeroField(name string) error {
	switch name {
	case "ResultSet":
		t.Value.ResultSet = map[string]ResolvedRow(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *ResolutionTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[string]ResolvedRow
type __VDLTarget11_map struct {
	Value      *map[string]ResolvedRow
	currKey    string
	currElem   ResolvedRow
	keyTarget  vdl.StringTarget
	elemTarget ResolvedRowTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget11_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]ResolvedRow)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]ResolvedRow)
	return t, nil
}
func (t *__VDLTarget11_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget11_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = reflect.Zero(reflect.TypeOf(t.currElem)).Interface().(ResolvedRow)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget11_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget11_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x Resolution) VDLIsZero() bool {
	if len(x.ResultSet) != 0 {
		return false
	}
	return true
}

func (x Resolution) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Resolution)(nil)).Elem()); err != nil {
		return err
	}
	if len(x.ResultSet) != 0 {
		if err := enc.NextField("ResultSet"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_8(enc, x.ResultSet); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_8(enc vdl.Encoder, x map[string]ResolvedRow) error {
	if err := enc.StartValue(vdl.TypeOf((*map[string]ResolvedRow)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Resolution) VDLRead(dec vdl.Decoder) error {
	*x = Resolution{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "ResultSet":
			if err := __VDLReadAnon_map_8(dec, &x.ResultSet); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_map_8(dec vdl.Decoder, x *map[string]ResolvedRow) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[string]ResolvedRow
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]ResolvedRow, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem ResolvedRow
		{
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[string]ResolvedRow)
		}
		tmpMap[key] = elem
	}
}

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}
	__VDLInitCalled = true

	// Register types.
	vdl.Register((*Value)(nil))
	vdl.Register((*ConflictRow)(nil))
	vdl.Register((*ConflictRowSet)(nil))
	vdl.Register((*ConflictScanSet)(nil))
	vdl.Register((*Conflict)(nil))
	vdl.Register((*ResolvedRow)(nil))
	vdl.Register((*Resolution)(nil))

	return struct{}{}
}
